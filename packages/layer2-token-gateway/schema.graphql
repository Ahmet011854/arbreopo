type Gateway @entity {
  "gateway address hex string"
  id: ID!
  "tokens this gateway supports"
  tokens: [TokenGatewayJoinTable!] @derivedFrom(field: "gateway")
}

type Token @entity {
  "l1 token address hex string"
  id: ID!
  "gateway that supports this token"
  gateway: [TokenGatewayJoinTable!] @derivedFrom(field: "token")
}

type TokenGatewayJoinTable @entity {
  "Set to concat `gateway.id` and `token.id`"
  id: ID!
  "block in which the token-gateway were associated"
  blockNum: BigInt!
  gateway: Gateway!
  token: Token!

  withdrawals: [GatewayWithdrawalData!] @derivedFrom(field: "tokenGatewayJoin")
  deposits: [GatewayDepositData!] @derivedFrom(field: "tokenGatewayJoin")
}

type GatewayDepositData @entity {
  "the L2 tx hash that got executed"
  id: ID!
  from: Bytes!
  to: Bytes!
  amount: BigInt!

  tokenGatewayJoin: TokenGatewayJoinTable!
  # l1ToL2Transaction: L1ToL2Transaction!
}

type GatewayWithdrawalData @entity {
  "this is the l2ToL1Id of the transaction as surfaced by arb-os"
  id: ID!
  from: Bytes!
  to: Bytes!
  amount: BigInt!
  exitNum: BigInt!

  tokenGatewayJoin: TokenGatewayJoinTable!
  l2ToL1Event: L2ToL1Transaction!
}

type L1ToL2Transaction @entity {
  "the L1 to L2 retryable creation id"
  id: ID!
  
  "aliased L1 address that called the inbox in the L1"
  from: Bytes! #address

  "L2 destination address of retryable"
  to: Bytes! #address

  "was this created before the nitro migration"
  isClassic: Boolean!

  "this is the amount of eth transfered from L1 to L2 that is creditted to the from account. note that eth can also be deposited through the eth deposit message which isn't tracked here"
  ethDepositAmount: BigInt!

  l2Calldata: Bytes!
  l2Callvalue: BigInt!

  # we are not able to corellate these 2 events, without indexing every block
  # gatewayDepositData: [GatewayDepositData!] @derivedFrom(field: "l1ToL2Transaction")

  # "the user tx hash of this retryable. undefined in nitro since"
  # userTxHash: Bytes # bytes32
}

type L2ToL1Transaction @entity {
  "a unique identifier used as a PK for the subgraph - deterministically generated from the uniqueId"
  id: ID!

  "the unique id surfaced by Arb-Os L2 to L1 tx - this might not always actually be unique when comparing pre vs post nitro"
  uniqueId: BigInt!

  "L2 Tx hash that triggered this event"
  l2TxHash: Bytes!

  caller: Bytes! # address
  destination: Bytes! # address
  
  "batch numbers are not available in nitro"
  batchNumber: BigInt # uint256

  "this is position in global merkle tree for nitro, but classic its within a batch num"
  indexInBatch: BigInt! # uint256

  arbBlockNum: BigInt! # uint256
  ethBlockNum: BigInt! # uint256
  timestamp: BigInt! # uint256
  callvalue: BigInt! # uint256
  data: Bytes! # bytes
  
  gatewayWithdrawalData: [GatewayWithdrawalData!] @derivedFrom(field: "l2ToL1Event")

  "indicates if this L2 to L1 tx was initiated before the nitro upgrade"
  isClassic: Boolean!
}
